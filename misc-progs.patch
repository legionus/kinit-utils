--- /dev/null	2009-10-26 16:14:39 +0300
+++ kinit/replace/replace.c	2009-10-28 15:35:31 +0300
@@ -0,0 +1,161 @@
+//#define SIMPLE 1
+
+#include <unistd.h>
+#ifndef SIMPLE
+#include <stdlib.h>
+#endif
+
+static const char usage[] = "Usage: replace [-s<char>] [-q] <src> <dst> [<string> ...]\n";
+static int quote = 0;
+static char stop_at = '\0';
+
+static void
+write_ch(const char c) {
+	if (write(1, &c, 1) == -1)
+		_exit(1);
+}
+
+static void
+print_ch(const char c) {
+	if (quote && (c == '\\' || c == '"' || c == '$' || c == '`'))
+		write_ch('\\');
+	write_ch(c);
+}
+
+#ifndef SIMPLE
+static void
+write_err(const char *s) {
+	if (write(2, s, sizeof(&s)-1) == -1)
+		_exit(1);
+}
+
+#define err(x) { write_err(x); _exit(1); }
+static char *
+expand(char *src) {
+	int i = 0, class = 0, ri = 0;
+	char prev = '\0';
+	char sequence[2] = { '\0', '\0' };
+	char *res = NULL;
+
+	res = (char *) malloc (sizeof(&src)-1);
+	if (!res) err("malloc failed");
+
+	while (src[i]) {
+		if (prev != '\\') {
+			switch (src[i]) {
+				case '[':
+					if (class)
+						err("Unexpected symbol `['\n");
+					class = 1;
+					goto end2;
+				case ']':
+					if (!class)
+						err("Unexpected symbol `]'\n");
+					class = 0;
+					goto end2;
+				case '-':
+					if (class && src[i+1] != '\0') {
+						if (sequence[1] == prev)
+							err("Unexpected symbol `-'\n");
+
+						sequence[0] = prev;
+						sequence[1] = src[i+1];
+						goto end2;
+					}
+			}
+		}
+
+		if (src[i] == '\\') {
+			if (prev == '\\') {
+				res[ri++] = '\\';
+				goto end2; 
+			}
+			goto end1;
+		}
+
+		if (src[i] == sequence[1]) {
+			res = realloc(res, sizeof(&res)+(unsigned)(sequence[1]-sequence[0]));
+			if (!res) err("realloc failed");
+
+			while (sequence[1] >= sequence[0])
+				res[ri++] = sequence[0]++;
+			goto end1;
+		}
+
+		if (!class)
+			res[ri++] = src[i];
+
+end1:		prev = src[i++];
+		continue;
+
+end2:		prev = '\0';
+		i++;
+	}
+	if (class)
+		err("Unexpected end of pattern\n");
+
+	res[ri] = '\0';
+	return res;
+}
+#endif
+
+int
+main(int argc, char **argv) {
+	size_t i = 1, j, k, len = 0;
+	char *src, *dst;
+
+	if (argc < 3) {
+		if (write(1, usage, sizeof(usage) - 1) == -1)
+			_exit(1);
+		return 0;
+	}
+
+	while (argv[i] && argv[i][0] == '-') {
+		if (!argv[i][1])
+			break;
+		else if (argv[i][1] == 'q')
+			quote = 1;
+		else if (argv[i][1] == 's' && argv[i][2])
+			stop_at = argv[i][2];
+		i++;
+	}
+
+#ifndef SIMPLE
+	src = expand(argv[i++]);
+	dst = expand(argv[i++]);
+#else
+	src = argv[i++];
+	dst = argv[i++];
+#endif
+	while (dst[len++]);
+
+	while (argv[i]) {
+		if (quote) write_ch('"');
+
+		j = 0;
+		while (argv[i][j]) {
+			if (argv[i][j] == stop_at)
+				break;
+			k = 0;
+			while (src[k] && argv[i][j] != src[k]) k++;
+
+			if (src[k]) {
+				if (k < len) print_ch(dst[k]);
+			}
+			else
+				print_ch(argv[i][j]);
+			j++;
+		}
+		while (argv[i][j])
+			print_ch(argv[i][j++]);
+			
+		if (quote) write_ch('"');
+		write_ch('\n');
+		i++;
+	}
+#ifndef SIMPLE
+	free(src);
+	free(dst);
+#endif
+	return 0;
+}
--- /dev/null	2009-10-26 16:14:39 +0300
+++ kinit/replace/Makefile	2009-10-28 15:35:31 +0300
@@ -0,0 +1,3 @@
+prog = replace
+objs = replace.o
+include $(CURDIR)/../rules.mk
--- /dev/null	2009-10-26 16:14:39 +0300
+++ kinit/printenv/printenv.c	2009-10-28 15:35:31 +0300
@@ -0,0 +1,58 @@
+#include <unistd.h>
+#include <stdio.h>
+
+static const char usage[] = "Usage: printenv [-q|-h]\n";
+static int quote = 0;
+
+static void
+write_ch(const char c) {
+	if (write(1, &c, 1) == -1)
+		_exit(1);
+}
+
+static void
+print_ch(const char c) {
+	if (quote && (c == '\\' || c == '"' || c == '$' || c == '`'))
+		write_ch('\\');
+	write_ch(c);
+}
+
+int main(int argc, char *argv[], char *envp[])
+{
+	int i = 0, j;
+
+	if (argc == 2 && argv[1][0] == '-') {
+		if (argv[1][1] == 'h') {
+			if (write(1, usage, sizeof(usage) - 1) == -1)
+				_exit(1);
+			return 0;
+		}
+		if (argv[1][1] == 'q')
+			quote = 1;
+	}
+
+	while (envp[i]) {
+		j = 0;
+		while(envp[i][j] != '=') j++;
+		envp[i][j] = '\0';
+
+		j = 0;
+		while(envp[i][j])
+			print_ch(envp[i][j++]);
+		j++;
+
+		write_ch('=');
+		if (quote)
+			write_ch('"');
+
+		while(envp[i][j])
+			print_ch(envp[i][j++]);
+
+		if (quote)
+			write_ch('"');
+		write_ch('\n');
+		i++;
+	}
+
+	return 0;
+}
--- /dev/null	2009-10-26 16:14:39 +0300
+++ kinit/printenv/Makefile	2009-10-28 15:35:31 +0300
@@ -0,0 +1,3 @@
+prog = printenv
+objs = printenv.o
+include $(CURDIR)/../rules.mk
--- /dev/null	2009-10-26 16:14:39 +0300
+++ kinit/ls/ls.c	2009-10-28 15:35:31 +0300
@@ -0,0 +1,202 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/sysmacros.h>
+
+#define STAT_ISSET(mode, mask) (((mode) & mask) == mask)
+
+static size_t max_linksiz = 128;
+static int max_nlinks = 1;
+static int max_size = 1;
+static int max_uid = 1;
+static int max_gid = 1;
+static int max_min = 1;
+static int max_maj = 1;
+
+static void do_preformat(const struct stat *st)
+{
+	int bytes;
+
+	if ((bytes = snprintf(NULL, 0, "%ld", (long) st->st_nlink)) > max_nlinks)
+		max_nlinks = bytes;
+
+	if ((bytes = snprintf(NULL, 0, "%ld", (long) st->st_uid)) > max_uid)
+		max_uid = bytes;
+
+	if ((bytes = snprintf(NULL, 0, "%ld", (long) st->st_gid)) > max_gid)
+		max_gid = bytes;
+
+	if (S_ISCHR(st->st_mode) || S_ISBLK(st->st_mode)) {
+		if ((bytes = snprintf(NULL, 0, "%u", major(st->st_rdev))) > max_maj)
+			max_maj = bytes;
+
+		if ((bytes = snprintf(NULL, 0, "%u", minor(st->st_rdev))) > max_min)
+			max_min = bytes;
+
+		max_size = max_maj + max_min + 1;
+	}
+	else {
+		if ((bytes = snprintf(NULL, 0, "%ld", (long) st->st_size)) > max_size)
+			max_size = bytes;
+	}
+	return;
+}
+
+static void do_stat(const struct stat *st, const char *path)
+{
+	char *fmt, *link_name;
+	int rc;
+
+	switch (st->st_mode & S_IFMT) {
+		case S_IFBLK:  putchar('b'); break;
+		case S_IFCHR:  putchar('c'); break;
+		case S_IFDIR:  putchar('d'); break;
+		case S_IFIFO:  putchar('p'); break;
+		case S_IFLNK:  putchar('l'); break;
+		case S_IFSOCK: putchar('s'); break;
+		case S_IFREG:  putchar('-'); break;
+		default:       putchar('?'); break;
+	}
+	putchar(STAT_ISSET(st->st_mode, S_IRUSR) ? 'r' : '-');
+	putchar(STAT_ISSET(st->st_mode, S_IWUSR) ? 'w' : '-');
+
+	!STAT_ISSET(st->st_mode, S_ISUID) ?
+		putchar(STAT_ISSET(st->st_mode, S_IXUSR) ? 'x' : '-') :
+		putchar('S');
+
+	putchar(STAT_ISSET(st->st_mode, S_IRGRP) ? 'r' : '-');
+	putchar(STAT_ISSET(st->st_mode, S_IWGRP) ? 'w' : '-');
+
+	!STAT_ISSET(st->st_mode, S_ISGID) ?
+		putchar(STAT_ISSET(st->st_mode, S_IXGRP) ? 'x' : '-') :
+		putchar('S');
+
+	putchar(STAT_ISSET(st->st_mode, S_IROTH) ? 'r' : '-');
+	putchar(STAT_ISSET(st->st_mode, S_IWOTH) ? 'w' : '-');
+
+	!STAT_ISSET(st->st_mode, S_ISVTX) ?
+		putchar(STAT_ISSET(st->st_mode, S_IXOTH) ? 'x' : '-') :
+		putchar(S_ISDIR(st->st_mode) ? 't' : 'T');
+
+	if (S_ISCHR(st->st_mode) || S_ISBLK(st->st_mode)) {
+		rc = asprintf(&fmt," %%%dld %%%dld %%%dld %%%du,%%%du %%s",
+		              max_nlinks, max_uid, max_gid, max_maj, max_min);
+		if (rc == -1) {
+			perror("asprintf");
+			exit(1);
+		}
+		fprintf(stdout, fmt,
+			(long) st->st_nlink,
+			(long) st->st_uid,
+			(long) st->st_gid,
+			major(st->st_rdev),
+			minor(st->st_rdev),
+			path);
+	}
+	else {
+		rc = asprintf(&fmt," %%%dld %%%dld %%%dld %%%dld %%s",
+		              max_nlinks, max_uid, max_gid, max_size);
+		if (rc == -1) {
+			perror("asprintf");
+			exit(1);
+		}
+		fprintf(stdout, fmt,
+			(long) st->st_nlink,
+			(long) st->st_uid,
+			(long) st->st_gid,
+			(long) st->st_size,
+			path);
+	}
+	free(fmt);
+
+	if (S_ISLNK(st->st_mode)) {
+		if ((link_name = malloc(max_linksiz)) == NULL) {
+			perror("malloc");
+			exit(1);
+		}
+		if ((rc = readlink(path, link_name, max_linksiz)) == -1) {
+			free(link_name);
+			perror("readlink");
+			exit(1);
+		}
+		link_name[rc] = '\0';
+		fprintf(stdout, " -> %s", link_name);
+		free(link_name);
+	}
+
+	putchar('\n');
+	return;
+}
+
+static void do_dir(const char *path, int preformat)
+{
+	DIR *dir;
+	struct dirent *dent;
+	struct stat st;
+
+	if (chdir(path) == -1) {
+		perror(path);
+		exit(1);
+	}
+
+	if ((dir = opendir(path)) == NULL) {
+		perror(path);
+		exit(1);
+	}
+
+	while ((dent = readdir(dir)) != NULL) {
+		if (lstat(dent->d_name, &st)) {
+			perror(dent->d_name);
+			exit(1);
+		}
+		(preformat) ?
+			do_preformat(&st) :
+			do_stat(&st, dent->d_name);
+	}
+
+	closedir(dir);
+}
+
+int main(int argc, char *argv[])
+{
+	int i;
+	struct stat st;
+
+	if (argc == 1) {
+		do_dir(".", 1);
+		do_dir(".", 0);
+		return 0;
+	}
+
+	for (i = 1; i < argc; i++) {
+		if (argv[i][0] == '-' && argv[i][1] == 'h') {
+			fprintf(stdout, "Usage: ls [-h] [FILE ...]\n");
+			return 0;
+		}
+
+		if (lstat(argv[i], &st)) {
+			perror(argv[i]);
+			exit(1);
+		}
+
+		S_ISDIR(st.st_mode) ?
+			do_dir(argv[i], 1) :
+			do_preformat(&st);
+	}
+
+	for (i = 1; i < argc; i++) {
+		if (lstat(argv[i], &st)) {
+			perror(argv[i]);
+			exit(1);
+		}
+
+		S_ISDIR(st.st_mode) ?
+			do_dir(argv[i], 0) :
+			do_stat(&st, argv[i]);
+	}
+
+	return 0;
+}
--- /dev/null	2009-10-26 16:14:39 +0300
+++ kinit/ls/Makefile	2009-10-28 15:35:31 +0300
@@ -0,0 +1,3 @@
+prog = ls
+objs = ls.o
+include $(CURDIR)/../rules.mk
--- kinit/Makefile.fix2	2009-10-28 15:37:23 +0300
+++ kinit/Makefile	2009-10-28 15:37:41 +0300
@@ -13,8 +13,11 @@ subdirs += nfsmount
 subdirs += run-init
 subdirs += fstype
 subdirs += resume
 subdirs += md_run
+subdirs += ls
+subdirs += replace
+subdirs += printenv
 
 # Additional include paths files
 CFLAGS +=  -I$(srctree)/$(src)/fstype \
            -I$(srctree)/$(src)/ipconfig \
